import cv2 as cv
import mediapipe as mp
import pyautogui, numpy, math
import pydirectinput as pd
mp_hands = mp.solutions.hands

#set up initial screen size
global xSize,ySize
xSize,ySize = pyautogui.size()

games = ["Minecraft","Lethal Company"] #games that use WASD

last_index_x, last_index_y,last_index_z = 0,0,0 #default starting values
last_thumb_index_distance = 0

#set up subroutines

def click(thumb_x,thumb_y,index_finger_x,index_finger_y):
    
    dist = math.sqrt((thumb_x-index_finger_x)**2 + (thumb_y-index_finger_y)**2)
    #print(dist)
    if dist <0.08: #tune
        #pyautogui.click() #redundancy
        pyautogui.mouseDown()
    else:
        pyautogui.mouseUp()

def move_mouse(index_finger_x,index_finger_y,last_index_x,last_index_y):
    global xSize,ySize
    
    xPos = int(xSize-(xSize * index_finger_x))#pyautogui uses left to right not right to left for x
    yPos = int(ySize * index_finger_y)

    movement_time = 0.5*math.sqrt(abs(index_finger_x -last_index_x))

    if abs(index_finger_x -last_index_x) >0.01 and abs(index_finger_y -last_index_y) >0.01: 
        
        pd.moveTo(xPos,yPos, movement_time) #,pyautogui.easeOutQuad) #time factor for interpolation in case of latency or vision system errors
    
    return(index_finger_x,index_finger_y)
    
    
def scroll(index_finger_x,index_finger_y,last_index_x,last_index_y): 
    global xSize, ySize
    
    deltaYPos = index_finger_y - last_index_y
    deltaXPos = index_finger_x - last_index_x

    scroll_amount = int((deltaYPos*ySize)*2)
    
    if deltaXPos <0.01 and deltaYPos > 0.02: #tune
        pyautogui.scroll(scroll_amount) #tune for optimal scrolling effectiveness
    
    #reset last x index
    last_x_index = index_finger_x
    last_y_index = index_finger_y
    return(last_index_x,last_index_y)

def switchTab(results,last_thumb_index_distance): #fix
    thumb = results[4]
    index_finger = results[8]
    dist = math.sqrt((thumb.x-index_finger.x)**2 + (thumb.y-index_finger.y)**2)
    deltaDist = dist-last_thumb_index_distance
    if deltaDist > 0.02 and dist >0.2: #open and opening hand
        pyautogui.keyDown('alt')
        pyautogui.press('tab')
        pyautogui.keyUp('alt')
    
    last_thumb_index_distance = dist
    return(last_thumb_index_distance)

def movePlayer(index_finger_z):
    if pyautogui.getActiveWindowTitle() == "Lethal Company":
            #control w and s
        if index_finger_z > -0.05: #default value
            pd.keyUp("w")
            pd.keyDown("s")
        elif index_finger_z < -0.10:
            pd.keyUp("s")
            pd.keyDown("w") #forwards
        else:
            pd.keyUp("w")
            pd.keyUp("s")


# For webcam input:
cap = cv.VideoCapture(0)
with mp_hands.Hands(
    model_complexity=0,
    min_detection_confidence=0.5,
    min_tracking_confidence=0.5) as hands:
  while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
      print("Ignoring empty camera frame.")
      # If loading a video, use 'break' instead of 'continue'.
      continue

    # To improve performance, optionally mark the image as not writeable to
    # pass by reference.
    frame.flags.writeable = False
    frame = cv.cvtColor(frame, cv.COLOR_BGR2RGB)
    results = hands.process(frame)
    if results.multi_hand_landmarks:
        for hand_landmarks in results.multi_hand_landmarks:
            #get landmark positions
                #index
            index_finger_x = hand_landmarks.landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP].x
            index_finger_y = hand_landmarks.landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP].y
            index_finger_z = hand_landmarks.landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP].z
            print(index_finger_z)
                #thumb
            thumb_x = hand_landmarks.landmark[mp_hands.HandLandmark.THUMB_TIP].x
            thumb_y = hand_landmarks.landmark[mp_hands.HandLandmark.THUMB_TIP].y

            #call subroutines given finger positions
            click(thumb_x, thumb_y, index_finger_x,index_finger_y)
            scroll(index_finger_x,index_finger_y,last_index_x,last_index_y)
            movePlayer(index_finger_z)
            move_mouse(index_finger_x,index_finger_y,last_index_x,last_index_y)
            last_index_x = index_finger_x
            last_index_y = index_finger_y
            
      
cap.release()
print("camera connection error. please restart code")
